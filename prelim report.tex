\documentclass[11pt]{article}
\usepackage{parskip}
\usepackage[margin=3.5cm]{geometry}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[shortlabels]{enumitem}
\usepackage{fancyhdr}
\usepackage{gensymb} %for degree symbol
\usepackage{graphicx} %to add figures to the document
\usepackage{subfigure} %used for side by side figures
\usepackage{url} %used for urls
\usepackage[nottoc]{tocbibind} %include references in toc
\usepackage[toc,page]{appendix} %used for appendix
\usepackage{listings} % used for R code
\usepackage{multirow} % multirows for tables
\usepackage{array}	% vertically centre contents in table cells
\usepackage{imakeidx} %add index
\usepackage{algorithm}
\usepackage{algpseudocode}
%\usepackage[boxruled, dotocloa]{algorithm2e} %pretty pseudocode
\lstset{language=R, basicstyle=\ttfamily} % To add R code in appendix
\graphicspath{ {C:/Users/Gemma/Documents/UNISA/Honours/Project 2017/02 Preliminary Report/} } %folder name where images are contained in the current directory
\DeclareMathSymbol{,}{0}{letters}{"3B}
\DeclareMathOperator{\argh}{argh}
\DeclareMathOperator*{\nut}{Nut}
\newcommand{\np}{\newpage}
\setcounter{secnumdepth}{-2} % to remove section numbering

\indexsetup{level=\section}
\makeindex[name=terms,title=Index of Terms,columns=2]
\makeindex[name=authors,title=Index of Authors,columns=2]	%initiate the index
\setcounter{page}{1}
\pagestyle{fancy}
\fancyhf{}
\rhead{Assignment 2: Preliminary Report\\ HONPR2C}
\lhead{Gemma Dawson\\ Student Number: 50223909}
\cfoot{\thepage}


\begin{document}

	\title{
		\begin{figure}[!htb]
			\begin{center}
				\includegraphics[width=12cm]{unisa.png}
			\end{center}
		\end{figure}
		Department of Decision Sciences\\[3mm]
		HONPR2C\\
		Project II \\[2cm]		
		{\huge \textbf{A statistical analysis of heuristics for the \emph{p}-median problem}}\\[15mm]
		Assignment 2: Preliminary Report\\[3mm]
		Assignment Unique Number: 650898\\[2cm]
	}
	\author{\textbf{\Large Gemma Dawson}\\[3mm]
		\textbf{\Large 50223909}\\[3mm]
		\textbf{Study Leader: Ms J L le Roux}
	}
	\date{\Large 30 August 2017}	
	\maketitle
	\thispagestyle{empty}
	\np
	
	\section*{Signed Declaration}
	I hereby declare that this project is my own work and that all the sources that I have used or quoted have been indicated and acknowledged by means of complete references.
	
	Signed:
	\begin{figure}[!htb]
			\includegraphics[width=4cm]{signature.png}
	\end{figure}

	Gemma Dawson\\
	Student Number: 50223909\\
	
	TO DO:
	\begin{enumerate}
		\item extend literature study to include more details on algorithms used
		
		\item ALTERNATE algorithm - code (Classic - LS)
		
		\item check the rules of citations and full stops - done?
		
		\item add a section discussing the diff between classical and meta heuristics - needs to be completed
		
		\item add explanation around how choices between identical improvements are made (i.e. randomly) 
		
		\item add complexity for each algorithm
		
		\item define "free node" in greedy (or first algorithm)

		
	\end{enumerate}
	\thispagestyle{empty}
	\np
	
	\tableofcontents
	\thispagestyle{empty}
	\np

\setcounter{page}{1}		
	\section{Introduction}
	The network facility location problem of finding a location for facilities or public services within a given space by optimising some predefined objective, is not a simple one.  Within the single-objective branch of network location problems, there is a plethora of papers exploring minisum, minimax, and covering problems.
	
	If the number of facilities needed is known and these facilities need to be located in the manner of minimising the total distance between demand nodes and their assigned facility, then the decision-maker is facing a \emph{p}-median problem.
	
	The \emph{p}-median problem \index[terms]{p-median problem} is well studied and many different approaches to finding both exact and approximate solutions have been proposed, but determining which method would be best for a particular problem is not clear.
	
	The study proposed will analyse and compare several heuristics applied to the \emph{p}-median problem in the hope that this decision may be made more clear.	
	
	
	\section{Description of the Problem}
	The uncapacitated \emph{p}-median problem has been widely studied and many different approaches to finding an acceptable, if not optimal, solution have been presented over the past fifty years.
	
	The focus of this study is to statistically analyse and compare the results obtained from various heuristic\index[terms]{heuristic} and metaheuristic\index[terms]{metaheuristic} algorithms applied to the \emph{p}-median problem\index[terms]{p-median problem}.
	
	Different heuristics applied to \emph{p}-median problems can produce varying quality of results dependant on the size of the original problem.  As algorithms\index[terms]{algorithm} take a considerable amount of time and research to be suitably set-up and run, it may be of benefit to have some prior knowledge of which heuristics may be suitable for the problem on hand.
	
	As such, the main objective of this proposed study would be to provide an indication of which method would be best suited to a given problem.
	
	This study will also investigate the computational time each algorithm requires to generate a solution, taking into account the size of the problem being solved.
	
	Since parametrisation of heuristics play a crucial part of the efficiency of the algorithm and the quality of the results it produces, this will be explained in detail in the study.  Given time, different approaches to the same heuristic may be explored as well.	
	
	
	\section{Methodology}
	All algorithms will be coded in R\index[terms]{R (programming language)} \cite{RPROGRAMME}, an open source programming language, due to its ease of use, extensive availability of online resources as well as the functionality provided by downloadable packages that provide useful data handling and visualisation.
	
	As the results of the algorithms\index[terms]{algorithm} under investigation are to be compared, identical problems need to be presented to each algorithm to solve.  Beasley \cite{BEAS90} \index[authors]{Beasley, J. E.} offers a forty-instance dataset\index[terms]{Beasley's test problem dataset} which comprises of problems ranging from 100 to 900 demand nodes that require the locations of between five and 200 medians to be determined.  These datasets ae given in a text format presenting the pairs of nodes along with their associated cost.  These text files were converted to cost matrices using the R package igraph \cite{RIGRAPH}.  These matrices provide the cost of traversing from one node to any other node in each network of the forty instances of the dataset.
	
	Beasley's library also provides the optimal solution's value of the weighted total distance objective function for each of the forty instances in the dataset.  This will allow the results obtained from the algorithms to be objectively assessed against the optimal solution.  The deviation of each algorithm's solution from the optimal solution will be analysed.  In addition, the computational time required for each algorithm will be logged and compared.
	

	\section{Literature Study}
	While the \emph{p}-median problem\index{p-median problem} may have been tackled by academics before 1964, it was first formally defined and formulated by Hakimi\index[authors]{Hakimi, S. L.} \cite{HAKI64}.  It was also in this paper that Hakimi\index[authors]{Hakimi, S. L.} proved that the optimal location of a facility in a connected discrete network would always be found to correspond to the location of a demand node.  This considerably reduces the solution search space.
	
	A few years later, ReVelle\index[authors]{ReVelle, C.} and Swain \index[authors]{Swain, R.}\cite{REVE70} formulated the \emph{p}-median problem as an integer programme \index[terms]{integer programme} which provided the answers to both the question of where the optimal medians were located as well as which demand nodes should be allocated to each median.  In this paper, the solution properties of solving this problem with linear programming \index[terms]{linear programming} using the branch-and-bound technique \index[terms]{linear programme!branch-and-bound} was also discussed.
	
	Later that decade, it was shown that the \emph{p}-median problem is NP-hard \index[terms]{NP-hard} and as such there exists no algorithm that can find the optimal solution within polynomial time.  Since most real-world problems are very large in nature, this poses a great problem.  Well developed heuristics\index[terms]{heuristic} can provide satisfactory solutions and many such approaches have been proposed.  Mladenovi\'{c}\index[authors]{Mladenovi\'{c}, N.} et al. \cite{MLAD07} produced a comprehensive survey of the heuristics that have been used to solve the \emph{p}-median problem.  This survey divides heuristics into two groups, classical heuristics and metaheuristics\index[terms]{metaheuristics}.  The classical heuristics group consists of constructive heuristics\index[terms]{heuristic!constructive}, such as the greedy algorithm\index[terms]{greedy algorithm}\index[terms]{heuristic!greedy algorithm}, local search\index[terms]{local search}\index[terms]{heuristic!local search}, and mathematical programming\index[terms]{mathematical programming}.  The metaheuristics group lists tabu search\index[terms]{tabu search}\index[terms]{metaheuristic!tabu search}, variable neighbourhood search\index[terms]{variable neighbourhood search}\index[terms]{metaheuristic!variable neighbourhood search}, and simulated annealing\index[terms]{simulated annealing}\index[terms]{metaheuristic!simulated annealing} among others.
	
	There do exist studies that analysis the efficiency of heuristics in solving the \emph{p}-median.  Simulated annealing\index{simulated annealing}\index[terms]{metaheuristic!simulated annealing} was analysed by Chiyoshi\index[authors]{Chiyoshi, F.}  and Galv\~{a}o \index[authors]{Galv\~{a}o, R. D.} \cite{CHIY00} while Alp\index[authors]{Alp, O.} et al. \cite{ALPO03} investigated their proposed genetic algorithm\index{genetic algorithm}.  Hansen\index{Hansen, P.} and Mladenovi\'{c}\index[authors]{Mladenovi\'{c}, N.} \cite{HANS01} applied the variable neighbourhood search algorithm\index[terms]{variable neighbourhood search}\index[terms]{metaheuristic!variable neighbourhood search} to the \emph{p}-median problem as well as heuristic concentration\index[terms]{heuristic concentration}, tabu search\index[terms]{tabu search}\index[terms]{metaheuristic!tabu search}, and the greedy interchange algorithm\index[terms]{greedy interchange algorithm}.  These studies used Beasley's test problem dataset\index[terms]{Beasley's test problem dataset} although Hansen\index[authors]{Hansen, P.}  and Mladenovi\'{c}'s\index[authors]{Mladenovi\'{c}, N.} review only used a portion of the available test problems.  
	
	Rolland\index[authors]{Rolland, E.} et al. \cite{ROLL97} explored the efficiency of tabu search\index[terms]{tabu search}\index[terms]{metaheuristic!tabu search} using randomly generated datasets as test problems, and this was compared to results obtained from a two-exchange heuristic\index[terms]{heuristic} and an integer programming\index[terms]{integer programming} algorithm.  A heuristic\index[terms]{heuristic} concentration was compared to tabu search by Rosing\index[authors]{Rosing, K. E.} et al. \cite{ROSI98}.  Since datasets were independently and randomly generated for each of these studies, it makes it very difficult to compare results.
	
	ADD MORE ABOUT THE ALGORITHMS USED IN THIS REPORT
	
	\section{Classical Heuristics and Metaheuristics}
	\subsection{Overview}
	As previously mentioned, a review of approaches to solving the \textit{p}-median problem\index[terms]{p-median} was presented by Mladenovi\'{c}\index[authors]{Mladenovi\'{c}, N.} et al. \cite{MLAD07} in 2007.  This paper divided heuristics\index[terms]{heuristic} into one of two groups, Classical Heuristics\index[terms]{heuristic!classical heuristic} and Metaheuristics\index[terms]{heuristic!metaheuristic}.  This classification has been utilised in this study.
	
	A heuristic can be classified as a Classical Heuristic 
	
	
	XXXXXXXXXXXXXXXXXXXXXXADD WHAT DIFFERENCE BETWEEN CLASSICAL \& META ISXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	
	\subsection{Pseudocode Notation}
	For each algorithm examined in this study, a pseudocode will be presented using notation given below.  This notation is the same as to that used by Whitaker \index[authors]{Whitaker, R. A.}\cite{WHIT83}.
	\begin{align*}
	G &: \text{the problem network}\\
	n &: \text{the number of nodes within the network}\\
	m &: \text{the number of nodes nodes that are available to be assigned as a median}\\
	p &: \text{the number of medians by required by the solution}\\
	M &: \text{the set of nodes that are available to be assigned as a median}\\
	P^{*} &: \text{the set of medians where } P^{*} \subset M\\
	P &: \text{the set of nodes not in the solution median set where } P \subset M \text{ and } P \cup P^{*} = M\\
	S^{*} &: \text{objective function value for supplying the network } G\\
	k &: \text{an iteration parameter}\\
	\infty &: \text{an arbitrarily large number}\\
	d_{ij} &: \text{the cost of travelling from node \emph{i} to potential median \emph{j}}\\
	u_{i}^{k} &: \text{the cost of travelling from node \emph{i} to the closest median \emph{j} where } j \in P^{*} \text{ during iteration } k\\
	w_{i}^{k} &: \text{the cost of travelling from node \emph{i} to the second closest median \emph{j} where } j \in P^{*} \text{ during iteration } k\\
	c_{j}^{k} &: \text{the potential value of \emph{S*} if node \emph{j} is added to the median set \emph{P*} during iteration \emph{k}}\\
	S_{r} &: \text{the value of \emph{S*} after adding node \emph{r} to the median set \emph{P*}}\\
	S_{rt} &: \text{the potential increase (or decrease) to S* resulting from the interchange of node \emph{r} with median \emph{t}}\\
	I \text{, } J \text{, } K_{j} &: \text{subsets of the \emph{n} nodes as defined XXXXXDEFINE THESE!XXXXX}\\
	a \text{, } b \text{, } z \text{, } q &: \text{indices and parameters as defined XXXXDEFINE!XXXX}\\
	\emptyset &: \text{an empty set}	
	\end{align*}
	

	\section{Classical Heuristics: Constructive}
	A constructive heuristic\index[terms]{constructive heuristic}\index[terms]{heuristic!constructive} is a technique that starts with an empty solution and each iteration extends this solution until a complete solution has been found.  Within the context of the unconstrained \emph{p}-median problem, for each iteration of the algorithm, a median is identified by some deterministic method and added to the current solution.  This process continues until the solution contains \emph{p} entries.
	
	\subsection{The Greedy Algorithm}
	The greedy algorithm, \index[terms]{greedy algorithm}\index[terms]{heuristic!greedy algorithm} as described by Whitaker \cite{WHIT83}, \index[author]{Whitaker, R. A.} is a simple recursive algorithm that starts with an empty median set and, with each iteration of the algorithm, adds a node to the median set.  The node that that is added to the median set is the one that decreases the objective function value the most when compared to the other non-median nodes.
	
	\subsubsection{Pseudocode}
	\index[terms]{greedy algorithm! pseudocode} 	
	
	\begin{algorithm}
	\caption{Greedy Algorithm}
	\begin{algorithmic}[0]
		
		\Statex
		\Statex STEP 0: Initialisation	
		\begin{equation*}
			\text{Set } P^{*} = \emptyset \text{; } k = 1\text{; and }u_i^1 = \infty\text{ for all } i=1,2,\dots,n
		\end{equation*}

		\Statex 
		\Statex STEP 1: For each free node, the objective function value resulting from selecting this node as a median is determined.  This objective function value is calculated by summing the cost of travel for each node in the network to either the closest median or the free node under investigation, whichever is smallest.
		\begin{equation*}
			c_j^k = \sum_{i=1}^{n}\min(d_{ij} \text{, } u_i^k) \quad \forall j \in M \text{, } j \notin P^*
		\end{equation*}

		\Statex 
		\Statex STEP 2: The free node that will result in the smallest increase to the objective function value is identified, and the objective function value is updated.
		\begin{equation*}
			S_r = \min_{j \notin P*}(c_j^k) \quad \text{for } r \in M \text{, } r \notin P^*
		\end{equation*}
		
		\Statex 
		\Statex STEP 3: Add node \emph{r} to the set of medians and then determine if the algorithm has completed the number of required iterations.
		\begin{equation*}
		P^* = P^* \cup r
		\end{equation*}
		
		\If{$k = p$}
			\Statex go to STEP 5
		[
		\Else
			\Statex go to STEP 4
		]
		\EndIf
		
		\Statex 
		\Statex STEP 4: Increase the value of iteration parameter and update the cost of travelling from any node to its closet median given that node $r$ has been added to the median set.
		\begin{align*}
		k &= k+1\\
		u_i^k &= \min(d_{ir} \text{, } u_i^{k-1}) \quad \text{for } i = 1,2,3 \dots,n
		\end{align*}
		\Statex Go to STEP 1
		
		\Statex 
		\Statex STEP 5: Once \emph{p} iterations are complete, set the final objective function value equal to the current iteration's objective function value and stop the algorithm.
		\begin{center}
		$S^{*} = S_r$\\
		STOP
		\end{center}
		
		
	\end{algorithmic}
	\end{algorithm}
	
	
	\subsection{The Fast Greedy Algorithm}
	Whitaker \cite{WHIT83} \index[authors]{Whitaker, R. A.} proposed the fast greedy algorithm. \index[terms]{heuristic!fast greedy algorithm}\index[terms]{constructive heuristic!fast greedy algorithm}\index[terms]{fast greedy algorithm} This algorithm differs from the greedy algorithm in that only the nodes that were re-assigned to a new median in the preceding iteration are investigated.  From these nodes, the new median is determined to be the one that will maximise the decrease in the objective function value.
	
	\subsubsection{Pseudocode}
	\index[terms]{fast greedy algorithm! pseudocode} 	
	\begin{algorithm}
		\caption{Fast Greedy Algorithm}
		\begin{algorithmic}[0]
			
			\Statex
			\Statex STEP 0: Initialisation 	
			\begin{align*}
			\text{Set } & P^{*} = \emptyset \text{; } I = \emptyset \text{; } k = 1\\
			& c_j^0=c_j^1 = 0 \text{ for }j\in M\\
			& u_i^0 = 0 \text{; } u_i^1 = \infty\text{ for all } i=1,2,\dots,n\\
			& I=I\cup i \text{ for } i=1,2,\dots,n
			\end{align*}
			
			\Statex
			\Statex STEP 1: For each free node that was reassigned to a new median in the previous iteration, the objective function value resulting from selecting this node as a median is determined.  This objective function value is calculated by summing the cost of travel for each node in the network to either the closest median or the free node under investigation, whichever is smallest.  For the first iteration, all nodes in the network are considered part of the reassigned set.
			\begin{equation*}
			c_j^k = \sum_{i\in I}\min(d_{ij} \text{, } u_i^k) + c_j^{k-1} - \sum_{i\in I}\min(d_{ij} \text{, } u_i^{k-1})\quad \forall j \in M \text{, } j \notin P^*
			\end{equation*}
			
			\Statex
			\Statex STEP 2: The free node that will result in the smallest increase to the objective function value is identified, and the objective function value is updated.
			\begin{equation*}
			S_r = \min_{j \notin P*}(c_j^k) \quad \text{for } r \in M \text{, } r \notin P^*
			\end{equation*}
			
			\Statex
			\Statex STEP 3: Add node \emph{r} to the set of medians and then determine if the algorithm has completed the number of required iterations.
			\begin{equation*}
			P^* = P^* \cup r
			\end{equation*}\\
			
			\If{$k = p$}
			\Statex go to STEP 5
			[
			\Else
			\Statex Set $I = \emptyset$ and go to STEP 4
			]
			\EndIf
			
					
			\Statex
			\Statex STEP 4: Increase the value of iteration parameter and update the cost of travelling from any node to its closet median given that node $r$ has been added to the median set.
			\begin{align*}
			k &= k+1\\
			u_i^k &= \min(d_{ir} \text{, } u_i^{k-1}) \quad \text{for } i = 1,2,3 \dots,n\\
			\end{align*}
			
			\If{$d_{ir}<u_i^{k-1}$}{$I=I\cup i$}
			\Statex go to STEP 1
			\EndIf
			
			\Statex
			\Statex STEP 5: Once \emph{p} iterations are complete, set the final objective function value equal to the current iteration's objective function value and stop the algorithm.
			\begin{center}
				$S^{*} = S_r$\\
				STOP
			\end{center}
				
		\end{algorithmic}
	\end{algorithm}
	
	\subsection{The Stingy Algorithm}
	The stingy algorithm was suggested by Feldman \index[author]{Feldman, }XXXXXXADD REFERENCE HERE - feldman 1966XXXXXXXXXXXx
	Instead of starting with an empty median set and recursively adding a node until all \textit{p} medians are assigned, the stingy algorithm\index[terms]{heuristics!stingy algorithm}\index[terms]{stingy algorithm}\index[terms]{constructive heuristic!stingy algorithm} begins with all nodes in the network being designated as a median.  A node is removed one at a time until only \textit{p} medians remain in the median set.
	
	\subsubsection{Pseudocode}
	
	
	\subsection{Computational Results}
	
	
	\section{Classical Heuristics: Local Search}
	A local search heuristic\index[terms]{heuristics!local search}\index[terms]{local search} differs from a constructive heuristic in that it starts with a feasible solution and each iteration attempts to improve this solution by some deterministic method.  This process continues until there is no better solution within reach of the current solution or some predetermined time-out is reached.
	
	\subsection{The Interchange Algorithm}
	
	
	\subsubsection{Pseudocode}
	
	
	\subsection{The Fast Interchange Algorithm}
	
	\subsubsection{Pseudocode}
	
	
	\subsection{The Alternate Algorithm}
	
	\subsubsection{Pseudocode}
	
	
	\subsection{Computational Results}
	
	
	
	\section{Conclusion}
		
		
	\np
	\bibliography{prelimbib}
	\bibliographystyle{IEEEtran}
	\np

	\printindex[terms]
	\printindex[authors]
	


\end{document}